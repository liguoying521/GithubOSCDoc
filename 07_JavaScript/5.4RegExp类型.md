## 传道

### 5.4.0 创建 RegExp 类型的对象

	// 方式1：使用字面量
	var reg = /pattern/flags;
	var reg = /\w\\hello\\123/gim;
	
	// 方式2：调用构造方法
	var reg = new RegExp("pattern", "flags");
	var reg = new RegExp("\\w\\\\hello\\\\123", "gim");

**pattern** 说明：
> 合法的正则表达式。

**flags** 说明：
> g : 全局模式(global)，模式对象能够记住上次匹配成功时的位置，下次匹配时，将从该位置的下一个字符开始；反之，如果不是全局模式，则每次都从字符串的第一个字符开始。

> i : 忽略大小写(ignoreCase)

> m : 多行模式(multiline)，到达一行的末尾时，还会继续查找下一行中是否有匹配的字符串

**注意：**
> 使用字面量的方式创建 RegExp 对象时，2 个斜线是必须的，即使没有正则表达式和标志字符串，也必须要有 2 个斜线，否则视为语法错误。

> 传递给 RegExp 构造方法的 2 个参数都是字符串，不能将 RegExp 字面量传递给构造方法。正则表达式中的元字符必须使用反斜线进行转义，而在字符串中使用反斜线是也必须要进行转义，所以当把正则表达式以字符串的形式传递给构造方法时，必须对正则表达式中的斜线再次进行转义。

### 5.4.1 RegExp 实例属性

RegExp 的每个实例都具有以下属性，通过这些属性可以取得有关模式的各种信息：

* gloabl : 布尔值，表示是否设置了 g 标志
* ignoreCase : 布尔值，表示是否设置了 i 标志
* multiline : 布尔值，表示是否设置了 m 标志
* lastIndex : 整数，表示搜索下一个匹配项的起始位置，从 0 开始
* source : 正则表达式的字符串表示(即字面量形式)

**注意：**
> lastIndex 属性仅在全局模式下有效，在非全局模式下它的值始终为 0，这就是为什么在非全局模式下总是从字符串的第一个字符开始匹配。

> source 属性始终返回正则表达式的字面量形式，即使是使用构造方法创建的。

### 5.4.2 RegExp 实例方法

RegExp 实例主要有 3 个实例方法：exec(str)、test(str)、compile()，下面分别介绍。

* exec(str) 

	**说明：**
	>exec 方法是专门用来获取匹配成功的字符序列的，它接收一个字符串作为参数，即要应用模式的字符串。

	**返回值：**
	>如果匹配成功，该方法返回一个数组，数组的第一项是与整个模式匹配的字符序列，其他项是与模式中的捕获组匹配的字符序列(第 2 项对应第 1 个捕获组，第 3 项对应第 2 个捕获组，捕获组的次序是按照左括号从左至右的顺序排的)，如果模式中不含捕获组，则数组中只有 1 项。
	>
	>如果匹配失败，则返回 null。

	>虽然 exec 返回的是 Array 的实例，但是它包含 2 个额外的属性：index 和 input。其中，index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。

### 5.4.3 RegExp 构造函数属性

## 解惑

* JS RegExp 中的 \w 代表任意的单词字符，那究竟什么是单词字符呢？？

	>JS中的单词字符包括：<br/>
	>字母（a ~z A ~ Z）<br/>
	>数字（0 ~ 9）<br/>
	>下划线（_）

* JS RegExp 中的 \b 用来匹配单词边界，那究竟什么是单词边界呢？？

	>想要解释什么是单词边界，首先得说明什么是单词，单词就是上面提及的单词字符连在一起，有单词字符就有非单词字符，单词字符用来组成单词，那非单词字符就是用来分隔单词，所以 \b 匹配的就是单词第一个单词字符前的那一个非单词字符和最后一个字符后的那一个非单词字符。

* ^((25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$ 中的捕获组

	>这是一个匹配 IP 的正则表达式，包含 3 个捕获组，分别是 `((25[0-5]|2[0-4]\d|[01]?\d?\d)\.)`、`(25[0-5]|2[0-4]\d|[01]?\d?\d)`、`(25[0-5]|2[0-4]\d|[01]?\d\d?)`，第 3 个捕获组比较简单，它会捕获 IP 中的第 4 段。
	>
	>前 2 个捕获组被数量限定符修饰了，那它们捕获的内容是 IP 中的第几段呢？？<br/>
	>实际上，它们捕获的是 IP 中的第 3 段，即最后一次匹配的文本。
	>
	>以 001.002.003.004 为例，第 1 个捕获组捕获的是 “003.”，第 2 个捕获组捕获的是 “003”，第 3 个捕获组捕获的是 “004”。

* 如何取消捕获组？？

	>还是以匹配 IP 的正则表达式为例来说明：`^((25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$`

	>这个正则表达式中包含 3 个捕获组，执行 RegExp 的 exec 方法返回的数组中会有它们 3 个捕获的内容，很多情况下，我们只想匹配 IP，而不需要捕获组，这时可以使用 `?:` 来关闭捕获组，如下所示：

	>`^(?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$`

<a name="category"/>
## 授业

### 目录

* [IP地址](#ip)

<a name="ip"/>
### IP地址正则表达式（[返回目录](#category)）

	var reg = /^((25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$/g;

IP地址的长度为32位，分为4段，每段8位，通常用“点分十进制”形式表示，每段数字范围为0~255。<br/>
例如：某台计算机IP地址为 `10.11.44.100` 。

IP地址4段的取值规则是相同的，所以我们只需分析一段即可。

0 ~ 255 的取值可以分为以下 3 种情况：<br/>
情况1：250 ~ 255<br/>
情况2：200 ~ 249<br/>
情况3：0 ~ 199

我们将上面 3 种情况分别用正则表达式表示出来：<br/>
情况1：25[0-5]<br/>
情况2：2[0-4]\d<br/>
情况3：[01]?\d?\d

情况3比较特殊，取值涉及到 1 位、2 位、3 位，还涉及到 0、01、001 这类取值，所以稍微分析一下：<br/>
情况3中至少要有 1 位数字，所以最后面的 `\d` 是必须的，它能代表 0 ~ 9 。<br/>
也可以有 2 位数字，所以倒数第二的是 `\d？`，即这个位置的数字可以出现 0 次或 1 次，到此为止，情况3能表示 0 ~ 99 。<br/>
也可以有 3 位数字，但是最高位只能为 0 或 1，所以倒数第三的是 `[01]?`，即这个位置的数字只能是 0 或 1，并且只能出现 0 次或 1 次，到此为止，情况3能表示 000 ~ 199(0 ~ 199)。

综上所述，匹配一段的正则表达式为：`25[0-5]|2[0-4]\d|[01]?\d?\d`

所以，到目前为止，匹配 IP 地址的正则表达式为：`((25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[01]?\d?\d)`

其实上面的正则表达式能做的是从字符串中匹配出正确的 IP 地址，但不能用来判断某个 IP 地址是否合法，具体表现在，当使用上面的正则表达式来判断 `256.000.000.256` 是否合法时，判断的结果是合法，这是因为上面的正则表达式能从该 IP 地址中匹配到合法地址 `56.000.000.25`，所以它认为该 IP 合法。

那为什么正则表达式会把 256 匹配成 56 和 25 呢？？<br/>
这个可以从正则表达式的匹配过程中分析出来，它从2开始匹配，到25时都可以匹配成功，但是当匹配到256时，匹配就失败了，这时它会继续从5开始匹配，所以56是成功的。同理，虽然256是非法的，但是25却是合法的，所以匹配25成功。

那该如何修改呢？？<br/>
解决方法也比较简单，我们只需让正则表达式匹配字符串的开始和结束即可，即使用 ^ 和 $ 。

所以可以用来判断 IP 地址是否合法的正则表达式为：`^((25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(25[0-5]|2[0-4]\d|[01]?\d\d?)$`